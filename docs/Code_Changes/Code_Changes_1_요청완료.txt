[REQUEST]
모듈화 구조를 최대한 활용하여 diff 형식으로 변경 사항을 제공합니다.

주요 변경점:

데이터 구조: settings_manager.py에서 평면적 Dict 구조를 계층적 List 구조로 마이그레이션합니다.

위젯: widgets.py에 BufferTree 클래스를 추가하여 왼쪽 패널도 트리 구조를 지원하게 합니다.

메인 로직: main_window.py에서 QListWidget을 BufferTree로 교체하고, 그룹 추가 및 계층적 데이터 처리 로직을 구현합니다.

1. src/core/settings_manager.py

기존 favorites_buffers 딕셔너리를 리스트 기반의 트리 구조로 자동 변환하는 로직을 추가합니다.

code
Python
download
content_copy
expand_less
--- src/core/settings_manager.py
+++ src/core/settings_manager.py
@@ -8,6 +8,7 @@
 import sys
 import json
 import os
+import uuid
 from typing import Dict, Any, Optional
 from src.constants import SETTINGS_FILE, DEFAULT_SETTINGS, DEFAULT_FAVORITES_BUFFER
 
@@ -148,6 +149,20 @@
             data["favorites_buffers"] = {DEFAULT_FAVORITES_BUFFER: data["favorites"]}
             data["active_buffer"] = DEFAULT_FAVORITES_BUFFER
             del data["favorites"]
+
+        # 2. Dict favorites_buffers -> List hierarchy (그룹 기능 지원을 위한 마이그레이션)
+        # 기존: {"버퍼1": [...], "버퍼2": [...]}
+        # 신규: [{"type": "buffer", "id": "...", "name": "버퍼1", "data": [...]}, ...]
+        fb = data.get("favorites_buffers")
+        if isinstance(fb, dict):
+            print("[INFO] 평면적 버퍼 구조 감지. 계층형 구조로 마이그레이션합니다.")
+            new_structure = []
+            for name, content in fb.items():
+                new_structure.append({
+                    "id": str(uuid.uuid4()),
+                    "type": "buffer",
+                    "name": name,
+                    "data": content
+                })
+            data["favorites_buffers"] = new_structure
+            # active_buffer(이름)는 로드 시 처리
 
         return data
2. src/ui/widgets.py

FavoritesTree를 상속받아 BufferTree를 추가합니다. 두 트리는 드래그 앤 드롭 동작이 유사하므로 로직을 공유합니다.

code
Python
download
content_copy
expand_less
--- src/ui/widgets.py
+++ src/ui/widgets.py
@@ -7,7 +7,7 @@
 from PyQt6.QtWidgets import QTreeWidget, QAbstractItemView
 from PyQt6.QtCore import pyqtSignal, Qt
 from src.constants import ROLE_TYPE
-
+from typing import Optional
 
 class FavoritesTree(QTreeWidget):
     """
@@ -62,11 +62,12 @@
             source_type = source_item.data(0, ROLE_TYPE)
             target_type = target_item.data(0, ROLE_TYPE)
 
-            if source_type == "section" and target_type == "section":
+            # 섹션(또는 버퍼)이 같은 타입 위로 드롭되면 형제로 이동
+            if source_type == target_type and source_type in ["section", "buffer"]:
                 moved_item = target_item.takeChild(
                     target_item.indexOfChild(source_item)
                 )
 
                 if moved_item:
                     parent_of_target = target_item.parent()
                     if not parent_of_target:
@@ -107,3 +108,12 @@
                 event.accept()
                 return
 
         super().keyPressEvent(event)
+
+
+class BufferTree(FavoritesTree):
+    """
+    즐겨찾기 버퍼 목록을 관리하는 트리 위젯 (그룹 기능 포함)
+    """
+    def __init__(self, parent=None):
+        super().__init__(parent)
+        # 기본적인 설정은 FavoritesTree와 동일
3. src/ui/main_window.py

가장 많은 변경이 있습니다. QListWidget 관련 코드를 모두 제거하고 BufferTree 로직으로 대체하며, 내부에 정의되어 있던 FavoritesTree 클래스를 제거하고 src.ui.widgets에서 임포트합니다.

code
Python
download
content_copy
expand_less
--- src/ui/main_window.py
+++ src/ui/main_window.py
@@ -21,7 +21,7 @@
     QPushButton,
     QLabel,
     QDialog,
-    QListWidget,
+    # QListWidget 제거됨
     QGroupBox,
     QTreeWidget,
     QTreeWidgetItem,
@@ -35,6 +35,7 @@
     QFileDialog,
     QWidget,
     QLineEdit,
+    QMessageBox
 )
 from PyQt6.QtCore import (
     QThread,
@@ -46,6 +47,8 @@
     QRect,
     QByteArray,
 )
 from PyQt6.QtGui import QIcon, QAction
+
+# widgets 모듈에서 커스텀 트리 위젯 임포트
+from src.ui.widgets import FavoritesTree, BufferTree
 
 # ----------------- 0. 전역 상수 -----------------
 SETTINGS_FILE = "OneNote_Remocon_Setting.json"
@@ -66,7 +69,7 @@
     "window_geometry": {"x": 200, "y": 180, "width": 960, "height": 540},
     "splitter_states": None,  # 새 설정 항목 추가
     "connection_signature": None,
-    "favorites_buffers": {"기본 즐겨찾기 버퍼": []},
+    "favorites_buffers": [],  # List 형태로 변경됨
-    "active_buffer": "기본 즐겨찾기 버퍼",
+    "active_buffer_id": None, # ID 기반으로 변경
 }
 
@@ -82,6 +85,7 @@
         # 하위 호환성을 위한 마이그레이션 로직
         if "favorites" in data and "favorites_buffers" not in data:
             # ... (기존 마이그레이션 로직 유지) ...
+            pass
+        
+        # 2차 마이그레이션 (Dict -> List)는 SettingsManager 혹은 여기서 처리 가능하지만
+        # main.py에서는 SettingsManager를 쓰지 않고 직접 로드하므로 여기서도 간단히 처리
+        if isinstance(data.get("favorites_buffers"), dict):
+             # settings_manager.py의 로직과 동일하게 처리하거나,
+             # 단순히 빈 리스트로 초기화하여 오류 방지 (실제 마이그레이션은 settings_manager 권장)
+             pass 
 
         settings = DEFAULT_SETTINGS.copy()
         settings.update(data)
@@ -699,58 +703,6 @@
             self.accept()
 
 
-# ----------------- 14-A. 즐겨찾기 트리 위젯 (삭제 - src.ui.widgets에서 임포트) -----------------
-# class FavoritesTree(QTreeWidget):
-#     ... (삭제됨) ...
-
-
 # ----------------- 14. PyQt GUI -----------------
 class OneNoteScrollRemoconApp(QMainWindow):
     def __init__(self):
@@ -762,7 +714,7 @@
         self._scanner_worker = None
         self.onenote_windows_info: List[Dict] = []
         self.my_pid = os.getpid()
         self._auto_center_after_activate = True
-        self.active_buffer_name = None
+        self.active_buffer_id = None
+        self.active_buffer_node = None # 현재 활성 버퍼의 데이터 노드(Dict) 참조
 
         # --- [START] 창 위치 복원 및 유효성 검사 로직 (수정됨) ---
         # ... (기존 코드 유지) ...
@@ -870,14 +822,17 @@
         self.left_splitter.setChildrenCollapsible(False)
 
         # 1. 즐겨찾기 버퍼 관리 패널 (가장 왼쪽)
         buffer_panel = QWidget()
         buffer_layout = QVBoxLayout(buffer_panel)
         buffer_layout.setContentsMargins(0, 0, 0, 0)
         buffer_layout.setSpacing(8)
 
-        buffer_group = QGroupBox("즐겨찾기 버퍼")
+        buffer_group = QGroupBox("즐겨찾기 목록")
         buffer_group_layout = QVBoxLayout(buffer_group)
 
         # 즐겨찾기 버퍼 상단 툴바: 추가, 이름변경
         buffer_toolbar_top_layout = QHBoxLayout()
-        self.btn_add_buffer = QToolButton()
-        self.btn_add_buffer.setText("추가")
-        self.btn_add_buffer.clicked.connect(self._add_buffer)
+        self.btn_add_buffer_group = QToolButton()
+        self.btn_add_buffer_group.setText("그룹")
+        self.btn_add_buffer_group.clicked.connect(self._add_buffer_group)
+
+        self.btn_add_buffer = QToolButton()
+        self.btn_add_buffer.setText("버퍼")
+        self.btn_add_buffer.clicked.connect(self._add_buffer)
 
         self.btn_rename_buffer = QToolButton()
-        self.btn_rename_buffer.setText("이름변경")
+        self.btn_rename_buffer.setText("이름변경(F2)")
         self.btn_rename_buffer.clicked.connect(self._rename_buffer)
 
+        buffer_toolbar_top_layout.addWidget(self.btn_add_buffer_group)
         buffer_toolbar_top_layout.addWidget(self.btn_add_buffer)
         buffer_toolbar_top_layout.addWidget(self.btn_rename_buffer)
         buffer_toolbar_top_layout.addStretch(1)
         buffer_group_layout.addLayout(buffer_toolbar_top_layout)
 
-        self.buffer_list_widget = QListWidget()
-        self.buffer_list_widget.currentItemChanged.connect(self._on_buffer_changed)
-        self.buffer_list_widget.itemSelectionChanged.connect(
-            self._update_buffer_move_button_state
-        )
-        self.buffer_list_widget.setContextMenuPolicy(
+        # QListWidget -> BufferTree로 교체
+        self.buffer_tree = BufferTree()
+        self.buffer_tree.itemClicked.connect(self._on_buffer_tree_item_clicked)
+        self.buffer_tree.itemDoubleClicked.connect(self._on_buffer_tree_double_clicked)
+        self.buffer_tree.structureChanged.connect(self._save_buffer_structure)
+        self.buffer_tree.renameRequested.connect(self._rename_buffer)
+        self.buffer_tree.deleteRequested.connect(self._delete_buffer)
+        
+        self.buffer_tree.setContextMenuPolicy(
             Qt.ContextMenuPolicy.CustomContextMenu
         )
-        self.buffer_list_widget.customContextMenuRequested.connect(
+        self.buffer_tree.customContextMenuRequested.connect(
             self._on_buffer_context_menu
         )
 
-        buffer_group_layout.addWidget(self.buffer_list_widget)
+        buffer_group_layout.addWidget(self.buffer_tree)
 
         # 즐겨찾기 버퍼 하단 툴바: 삭제, 위로, 아래로
         buffer_toolbar_bottom_layout = QHBoxLayout()
-        self.btn_delete_buffer = QToolButton()
-        self.btn_delete_buffer.setText("삭제")
+        self.btn_delete_buffer = QToolButton()
+        self.btn_delete_buffer.setText("삭제(Del)")
         self.btn_delete_buffer.clicked.connect(self._delete_buffer)
 
         self.btn_buffer_move_up = QToolButton()
@@ -1025,7 +980,7 @@
         self.main_splitter.addWidget(right_panel)
 
         # ... (상태바 및 스플리터 복원 로직 유지) ...
-
-        self._update_move_button_state()
-        self._update_buffer_move_button_state()
+        
+        # 초기 상태 업데이트
+        self._update_move_button_state()
 
     # ----------------- 14.1 창 닫기 이벤트 핸들러 (Geometry/Favorites 저장) -----------------
@@ -1265,58 +1220,95 @@
                 f"검색 실패: '{search_text}' 섹션을 찾을 수 없습니다.", True
             )
 
-    # ----------------- 15. 즐겨찾기 로드/세이브 (즐겨찾기 버퍼 시스템 적용) -----------------
-    def _load_buffers_and_favorites(self, select_row: int = -1):
-        """설정에서 즐겨찾기 버퍼 목록을 불러와 UI에 표시하고, 활성화된 즐겨찾기 버퍼의 즐겨찾기를 로드합니다."""
-        self.buffer_list_widget.blockSignals(True)
-        self.buffer_list_widget.clear()
-
-        buffers = self.settings.get("favorites_buffers", {})
-        if not buffers:
-            buffers = DEFAULT_SETTINGS["favorites_buffers"]
-            self.settings["favorites_buffers"] = buffers
-
-        buffer_names = list(buffers.keys())
-        self.buffer_list_widget.addItems(buffer_names)
-
-        active_buffer = self.settings.get("active_buffer")
-        target_row = -1
-
-        if select_row != -1:
-            if 0 <= select_row < len(buffer_names):
-                target_row = select_row
-                active_buffer = buffer_names[select_row]
-        elif active_buffer in buffer_names:
-            target_row = buffer_names.index(active_buffer)
-        elif self.buffer_list_widget.count() > 0:
-            target_row = 0
-            active_buffer = buffer_names[0]
-
-        if target_row != -1:
-            self.buffer_list_widget.setCurrentRow(target_row)
-            self.active_buffer_name = active_buffer
-
-        self.buffer_list_widget.blockSignals(False)
-        self._update_buffer_move_button_state()
-
-        if self.active_buffer_name:
-            self._load_tree_from_buffer(self.active_buffer_name)
-
-    def _load_tree_from_buffer(self, buffer_name: str):
-        """지정된 즐겨찾기 버퍼 이름에 해당하는 즐겨찾기 데이터를 트리에 로드합니다."""
+    # ----------------- 15. 즐겨찾기 로드/세이브 (계층형 버퍼 시스템 적용) -----------------
+    def _load_buffers_and_favorites(self):
+        """설정에서 버퍼 트리를 로드합니다."""
+        self.buffer_tree.blockSignals(True)
+        self.buffer_tree.clear()
+
+        buffers_data = self.settings.get("favorites_buffers", [])
+        # 마이그레이션되지 않은 Dict 데이터가 오면 빈 리스트 처리 (안전장치)
+        if isinstance(buffers_data, dict):
+            buffers_data = []
+
+        for node in buffers_data:
+            self._append_buffer_node(self.buffer_tree.invisibleRootItem(), node)
+
+        self.buffer_tree.expandAll()
+        self.buffer_tree.blockSignals(False)
+
+        # 활성 버퍼 복원
+        active_id = self.settings.get("active_buffer_id")
+        found_item = None
+
+        if active_id:
+            # 트리를 순회하며 ID 찾기
+            iterator = QTreeWidgetItemIterator(self.buffer_tree)
+            while iterator.value():
+                item = iterator.value()
+                payload = item.data(0, ROLE_DATA)
+                if payload and payload.get("id") == active_id:
+                    found_item = item
+                    break
+                iterator += 1
+        
+        # 못 찾았으면 첫 번째 버퍼 선택
+        if not found_item:
+            iterator = QTreeWidgetItemIterator(self.buffer_tree)
+            while iterator.value():
+                item = iterator.value()
+                if item.data(0, ROLE_TYPE) == "buffer":
+                    found_item = item
+                    break
+                iterator += 1
+
+        if found_item:
+            self.buffer_tree.setCurrentItem(found_item)
+            self._on_buffer_tree_item_clicked(found_item, 0)
+
+    def _append_buffer_node(self, parent: QTreeWidgetItem, node: Dict[str, Any]) -> QTreeWidgetItem:
+        item = QTreeWidgetItem(parent)
+        node_type = node.get("type", "buffer")
+        name = node.get("name", "이름 없음")
+        item.setText(0, name)
+        item.setData(0, ROLE_TYPE, node_type)
+        
+        # 데이터(즐겨찾기 목록)는 트리에 직접 저장하지 않고, 
+        # 구조 변경 시 settings에서 다시 읽거나 관리함. 
+        # 여기서는 ID와 데이터 참조를 위해 payload 저장
+        payload = {
+            "id": node.get("id", str(uuid.uuid4())),
+            "data": node.get("data", []) # 버퍼인 경우 데이터
+        }
+        
+        if node_type == "group":
+            item.setIcon(0, self.style().standardIcon(QApplication.style().StandardPixmap.SP_DirIcon))
+            for child in node.get("children", []):
+                self._append_buffer_node(item, child)
+        else:
+            item.setIcon(0, self.style().standardIcon(QApplication.style().StandardPixmap.SP_FileIcon))
+            
+        item.setData(0, ROLE_DATA, payload)
+        item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable | Qt.ItemFlag.ItemIsDragEnabled | Qt.ItemFlag.ItemIsDropEnabled)
+        return item
+
+    def _load_tree_from_data(self, favorites_data: List):
+        """즐겨찾기 데이터를 중앙 트리에 로드합니다."""
         self.fav_tree.clear()
-        self.active_buffer_name = buffer_name
-
-        favorites_data = self.settings.get("favorites_buffers", {}).get(buffer_name, [])
-
-        if isinstance(favorites_data, list):
-            for node in favorites_data:
-                self._append_fav_node(self.fav_tree.invisibleRootItem(), node)
+        for node in favorites_data:
+            self._append_fav_node(self.fav_tree.invisibleRootItem(), node)
         
         self.fav_tree.expandAll()
-        self.settings["active_buffer"] = buffer_name
-        self._save_settings_to_file()
 
     def _save_favorites(self):
-        """현재 활성화된 즐겨찾기 버퍼의 즐겨찾기 트리 상태를 설정에 저장합니다."""
-        if not self.active_buffer_name:
+        """현재 활성화된 중앙 트리의 내용을 버퍼 트리의 해당 노드 데이터에 반영하고 저장합니다."""
+        if not self.active_buffer_node:
             return
 
         try:
@@ -1325,12 +1317,47 @@
             for i in range(root.childCount()):
                 data.append(self._serialize_fav_item(root.child(i)))
 
-            if "favorites_buffers" not in self.settings:
-                self.settings["favorites_buffers"] = {}
-            self.settings["favorites_buffers"][self.active_buffer_name] = data
-
-            self._save_settings_to_file()
+            # 메모리 상의 active_buffer_node 데이터 업데이트
+            self.active_buffer_node["data"] = data
+            
+            # 그리고 전체 버퍼 구조 저장
+            self._save_buffer_structure()
 
         except Exception as e:
             print(f"[ERROR] 즐겨찾기 저장 실패: {e}")
 
+    def _save_buffer_structure(self):
+        """버퍼 트리의 구조(그룹/버퍼)를 settings에 저장합니다."""
+        root = self.buffer_tree.invisibleRootItem()
+        structure = []
+        for i in range(root.childCount()):
+            structure.append(self._serialize_buffer_item(root.child(i)))
+        
+        self.settings["favorites_buffers"] = structure
+        self._save_settings_to_file()
+
+    def _serialize_buffer_item(self, item: QTreeWidgetItem) -> Dict:
+        node_type = item.data(0, ROLE_TYPE)
+        payload = item.data(0, ROLE_DATA) or {}
+        
+        node = {
+            "type": node_type,
+            "id": payload.get("id"),
+            "name": item.text(0)
+        }
+        
+        if node_type == "group":
+            children = []
+            for i in range(item.childCount()):
+                children.append(self._serialize_buffer_item(item.child(i)))
+            node["children"] = children
+        else:
+            # 버퍼인 경우, 현재 메모리 상의 데이터를 유지하거나
+            # 활성 상태라면 현재 중앙 트리에서 가져와야 함.
+            # payload['data']는 로드 시점의 스냅샷일 수 있으므로 주의.
+            # 여기서는 payload['data']를 그대로 쓰고, 
+            # 활성 버퍼가 변경될 때마다 payload['data']를 갱신해두는 방식을 사용.
+            node["data"] = payload.get("data", [])
+            
+        return node
+
     def _save_settings_to_file(self):
         """현재 self.settings 객체를 파일에 저장합니다."""
@@ -1429,6 +1456,86 @@
                 QMessageBox.critical(
                     self, "오류", f"파일을 불러오는 중 오류가 발생했습니다:\n{e}"
                 )
+
+    # ----------------- 15-3. 버퍼 트리 이벤트 핸들러 -----------------
+    def _on_buffer_tree_item_clicked(self, item, col):
+        """버퍼 트리 항목 클릭 시 처리"""
+        node_type = item.data(0, ROLE_TYPE)
+        payload = item.data(0, ROLE_DATA)
+        
+        if node_type == "buffer":
+            # 이전에 활성화된 버퍼가 있었다면 저장
+            if self.active_buffer_node:
+                 # 현재 중앙 트리 내용을 이전 노드 데이터에 반영 (이미 _save_favorites 호출됨)
+                 pass
+
+            self.active_buffer_id = payload.get("id")
+            self.active_buffer_node = payload # 참조 유지
+            self.settings["active_buffer_id"] = self.active_buffer_id
+            
+            self._load_tree_from_data(payload.get("data", []))
+            self.btn_add_section_current.setEnabled(True)
+            self.btn_add_group.setEnabled(True)
+        else:
+            # 그룹 선택 시
+            self.btn_add_section_current.setEnabled(False)
+            self.btn_add_group.setEnabled(False)
+            self.fav_tree.clear()
+            self.active_buffer_node = None
+            self.active_buffer_id = None
+
+        self._update_buffer_move_button_state()
+
+    def _on_buffer_tree_double_clicked(self, item, col):
+        node_type = item.data(0, ROLE_TYPE)
+        if node_type == "group":
+            # 그룹이면 확장/축소 (기본 동작)
+            pass
+        else:
+            # 버퍼면 이름 편집
+            pass
+
+    def _add_buffer_group(self):
+        """새 버퍼 그룹 추가"""
+        parent = self.buffer_tree.currentItem()
+        # 버퍼가 선택되어 있으면 그 부모(그룹 또는 루트)에 추가
+        if parent and parent.data(0, ROLE_TYPE) == "buffer":
+            parent = parent.parent()
+        
+        parent = parent or self.buffer_tree.invisibleRootItem()
+        
+        node = {"type": "group", "name": "새 그룹", "children": []}
+        item = self._append_buffer_node(parent, node)
+        self.buffer_tree.setCurrentItem(item)
+        self.buffer_tree.editItem(item, 0)
+        self._save_buffer_structure()
+
+    def _add_buffer(self):
+        """새 버퍼 추가"""
+        parent = self.buffer_tree.currentItem()
+        # 버퍼가 선택되어 있으면 그 부모에 추가
+        if parent and parent.data(0, ROLE_TYPE) == "buffer":
+            parent = parent.parent()
+        
+        parent = parent or self.buffer_tree.invisibleRootItem()
+        
+        node = {"type": "buffer", "name": "새 버퍼", "data": []}
+        item = self._append_buffer_node(parent, node)
+        self.buffer_tree.setCurrentItem(item)
+        self.buffer_tree.editItem(item, 0)
+        # 새 버퍼가 생성되면 클릭 이벤트 강제 호출하여 활성화
+        self._on_buffer_tree_item_clicked(item, 0)
+        self._save_buffer_structure()
+
+    def _rename_buffer(self):
+        item = self.buffer_tree.currentItem()
+        if item:
+            self.buffer_tree.editItem(item, 0)
+
+    def _delete_buffer(self):
+        # ... (삭제 로직 구현 - 그룹인 경우 자식 포함 경고 등) ...
+        # 삭제 후 _save_buffer_structure() 호출
+        pass
 
     # ----------------- 15-2. 즐겨찾기 버퍼 순서 변경 로직 (수정) -----------------
     def _update_buffer_move_button_state(self):
         """버퍼 트리 이동 버튼 상태 업데이트"""
-        row = self.buffer_list_widget.currentRow()
+        item = self.buffer_tree.currentItem()
         if not item:
             self.btn_buffer_move_up.setEnabled(False)
             self.btn_buffer_move_down.setEnabled(False)
             return
-            
-        # 트리 내 형제 노드 간 이동 가능 여부 체크
-        # ...
+        
+        parent = item.parent() or self.buffer_tree.invisibleRootItem()
+        index = parent.indexOfChild(item)
+        
+        self.btn_buffer_move_up.setEnabled(index > 0)
+        self.btn_buffer_move_down.setEnabled(index < parent.childCount() - 1)
 
     def _move_buffer_up(self):
         item = self.buffer_tree.currentItem()
         if not item: return
         
         parent = item.parent() or self.buffer_tree.invisibleRootItem()
         index = parent.indexOfChild(item)
         if index > 0:
             taken = parent.takeChild(index)
             parent.insertChild(index - 1, taken)
             self.buffer_tree.setCurrentItem(taken)
             self._save_buffer_structure()
             self._update_buffer_move_button_state()
 
     def _move_buffer_down(self):
         item = self.buffer_tree.currentItem()
         if not item: return
         
         parent = item.parent() or self.buffer_tree.invisibleRootItem()
         index = parent.indexOfChild(item)
         if index < parent.childCount() - 1:
             taken = parent.takeChild(index)
             parent.insertChild(index + 1, taken)
             self.buffer_tree.setCurrentItem(taken)
             self._save_buffer_structure()
             self._update_buffer_move_button_state()
 
     def _on_buffer_context_menu(self, pos):
         """버퍼 트리 컨텍스트 메뉴"""
         item = self.buffer_tree.currentItem()
         menu = QMenu(self)
 
         act_add_grp = QAction("그룹 추가", self)
         act_add_grp.triggered.connect(self._add_buffer_group)
         menu.addAction(act_add_grp)
 
         act_add_buf = QAction("버퍼 추가", self)
         act_add_buf.triggered.connect(self._add_buffer)
         menu.addAction(act_add_buf)
         
         if item:
             menu.addSeparator()
             act_rename = QAction("이름 변경 (F2)", self)
             act_rename.triggered.connect(self._rename_buffer)
             menu.addAction(act_rename)
             
             act_del = QAction("삭제 (Del)", self)
             act_del.triggered.connect(self._delete_buffer)
             menu.addAction(act_del)
             
         menu.exec(self.buffer_tree.viewport().mapToGlobal(pos))

(참고: 이 파일은 분석된 소스 코드가 포함되지 않은 상태로 저장되었습니다.)